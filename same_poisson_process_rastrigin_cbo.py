# -*- coding: utf-8 -*-
"""Same Poisson process Rastrigin CBO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lb0g_CgFQotxSaa74VHdDHXX8r4Dw5QR
"""

import math
import numpy as np
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from tqdm import tqdm_notebook as tqdm

"""dX(i,t) = -lambda_val * (X(i,t) - m_t) * dt + sigma * (X(i,t) - m_t) * dW(t)"""

class BaseCBO:
  def __init__(self, function = None, alpha = 30, beta = 1, sigma = 5.1,
               n_agents = 50, pos_vec = 20 , total_time = 100, h = 0.01):
    self.f = function
    self.alpha = alpha
    self.beta = beta
    self.sigma = sigma
    self.n_agents = n_agents
    self.total_time = total_time
    self.h = h
    self.iterations = int(self.total_time / self.h)
    #print("Iterations are ", self.iterations)
    self.pos_vec = pos_vec
    #self.f_x = self.f(X)

  def initialize_uniform(self, lower_limit = -3, upper_limit = 3):
    size = (self.n_agents, self.pos_vec)
    return np.random.uniform(lower_limit, upper_limit, size = size)


  def w_f(self,X,f_x):
    #f_x =self.f(X)
    #return np.exp(-1 * self.alpha * (f_x - np.amax(f_x)))
    return np.exp(-1 * self.alpha * (f_x))

  def x_bar(self,X,f_x):
    #num = np.log(X) - self.alpha*f_x[:,None] + self.alpha*np.amax(f_x) - np.log(np.sum(self.w_f(X,f_x)))
    num = np.sum(X * self.w_f(X,f_x)[:,None],0)
    den = np.sum(self.w_f(X,f_x))
    #numlog = np.log(num)
    #denlog = np.log(den)
    #logdif = numlog - denlog
    #if np.isnan(num/den).any():
    #  min_f_index = self.f(X).argmin()
    #  return X[min_f_index,:]
    #else:
    #num = np.exp(num)
    #num = np.sum(num,0)
    return num/den
  
  def difference(self,X):
    f_x = self.f(X)
    return X - self.x_bar(X,f_x)[None,:]

  
  def drift(self, X):
    return -1 * self.beta * self.difference(X) * self.h

  def diffusion(self,X):
    size = (self.n_agents, self.pos_vec)
    W_t = np.random.normal(size  = size)
    return self.sigma * self.difference(X) * W_t * np.sqrt(self.h*2)


  def update_step(self,X):
     return self.drift(X) + self.diffusion(X)

  def start_update(self,X):
    t = 0
    size = (self.n_agents, self.pos_vec)
    Y = np.zeros(size)
    Z = 0
    B = 0
    C= self.n_agents*self.iterations*self.pos_vec
    A = []
    #a = 5*np.array(range(1,21))
    B = 0
    C= self.n_agents*self.iterations*self.pos_vec
    a = 5*np.array(range(1,21))/self.h -1 
    for i in range(self.iterations):
      
      Y = self.update_step(X)
      X = X + Y
      B = Y**2
      Z = Z + np.sum(B)/C
      
      if i in a:
        A.append(Z)
      
      
      

      #if np.isnan(X).any():
      #  print("Iteration is ", i)
      #  print("w_f is ", self.w_f(X))
      #  print("m_t is", self.x_bar(X))
      #  print("X is ",X)
      #  break
    A = np.array(A)
    #print("x_bar is ", self.x_bar(X))
    #print("value of f is ", self.f(self.x_bar(X)))
    f_x = self.f(X)
    return [self.x_bar(X,f_x), A]

  def optim_value(self,X):
    return self.f(X)

"""dX(i,t) = -lambda_val * (X(i,t) - m_t) * dt + sigma * (X(i,t) - m_t) * dW(t) + SUM_s=0_s=N(t){delta_X(i,s) * (X(i,t) - m_t)}"""

class JumpCBO(BaseCBO):
  def __init__(self, lambda_val = 50, type_rv = "poisson", **kwargs):
    super().__init__(**kwargs)
    self.lambda_val = lambda_val #Jump Intensity
    self.type_rv = type_rv

  def poisson_rv(self):
    return np.random.poisson(self.h*self.lambda_val,1)[0]

  def binomial_rv(self):
    return np.random.binomial(1,self.h*self.lambda_val,1)[0]

  def drift(self, X, i):
     t = i*self.h
     #if t <= 80:
     return -1 * self.beta * self.difference(X) * self.h
     #else:
     #  return -1 * (self.beta/2 + self.beta*((1.001)**((t/80) - 1))/2) * self.difference(X) * self.h
     
  def diffusion(self, X, i):
    size = (self.n_agents, self.pos_vec)
    W_t = np.random.normal(size = size)
    t = i*self.h
    #if t <= 80:
    return self.sigma  * self.difference(X) * W_t * np.sqrt(self.h*2)
    #else:
    #   return (self.sigma/2 + self.sigma*(0.99**((t/80) -1))/2) * self.difference(X) * W_t * np.sqrt(self.h*2)
    #return   

  #def sigma_t(self,i,k=10):
  # t = i * self.h
  # return math.pow(0.99,t/k)

  def jumps(self,X, i):
    t = i*self.h
    size  = (self.n_agents, self.pos_vec)
    diff_X = self.difference(X)
    if self.type_rv == "binomial":
      if self.binomial_rv() == 1:
        jp = np.random.normal(size = size)
        return ((0.99)**(t/20))*jp * diff_X  
      else:
        return 0
    
    else:
      k = self.poisson_rv()
      if k != 0:
       jps = np.zeros(size)
       gamma = 1 
       for _ in range(k):
          jps = jps +  np.random.normal(size = size)
          #if t <= 80:
          #  return jps * self.difference(X) #np.exp(-i*self.h/40)
          #else:
          if i*self.h <= 20:
             return jps * self.difference(X) #np.exp(-i*self.h/40)
          else:
             return np.exp(1-i*self.h/20)*jps * self.difference(X)  
      else:
        return 0
    
    


  def update_step(self,X,i):
    return self.drift(X,i) + self.diffusion(X,i) + self.jumps(X,i)

  def start_update(self,X):
    t = 0
    size = (self.n_agents, self.pos_vec)
    Y = np.zeros(size)
    Z = 0
    A = []
    #a = 5*np.array(range(1,21))
    B = 0
    C= self.n_agents*self.iterations*self.pos_vec
    a = 5*np.array(range(1,21))/self.h  -1
    for i in range(self.iterations):
      Y = self.update_step(X,i)
      X = X + Y
      B = Y**2
      Z = Z + np.sum(B)/C
      if i in a:
        A.append(Z)
      
      
      

   #   if np.isnan(X).any():
   #     print("Iteration is ", i)
   #     print("w_f is ", self.w_f(X))
   #     print("m_t is", self.m_t(X))
   #     print("X is ",X)
   #     break
    #print("m_t is", self.m_t(X))
    A = np.array(A)
    f_x = self.f(X)
    #print("x_bar is ", self.x_bar(X))
    return [self.x_bar(X,f_x), A]

class rastrigin:
  def __init__(self, dim, B = None):
    self.dim = dim
    self.B = B
    if self.B is None:
      self.B = 0

  def __call__(self,X):
    B = self.B
    if len(X.shape) == 2:
      pass
    else:
      X = X[None,:]
    return (np.sum((X-B)**2 - 10 * np.cos(2* np.pi * (X-B)) + 10,1)) / self.dim

def success_rate(cbo_object,m = 100, lower_limit = -3, upper_limit = 3, minima = None):
  success = 0 
  spread = []
  final_pos = []
  distance = []
  if minima is None:
    minima = np.zeros(cbo_object.pos_vec)
  for j in range(m):
    #print("M is ", j+1)
    X = cbo_object.initialize_uniform(lower_limit, upper_limit)
    [opt_X, A] = cbo_object.start_update(X)
    #print("Final_X ",opt_X)
    dist = np.linalg.norm(opt_X - minima)
    spread.append(A)
    final_pos.append(opt_X)
    distance.append(dist**2)
    if dist < 0.25:
      success = success + 1
  final_pos = np.array(final_pos)      
  spread = np.array(spread) 
  distance = np.array(distance)
  distance = np.nanmean(distance)
  spreadmeasure = np.nanmean(spread,0)
  spreadmeasure = np.log(spreadmeasure)
  sr = success/m 
  print("Success rate is ", sr)
  print("distance is ", distance)
  print(" spread is ", spreadmeasure)
  #print("final positions are ", final_pos)
  # print("\n")
  # print(opt_X)
  # print(basecbo.optim_value(opt_X))

agents = [20,50,80,100]
for k in agents:
  basecbo = BaseCBO(function = rastrigin(dim = 20), pos_vec = 20, n_agents = k, total_time = 100)
  success_rate(basecbo,lower_limit = 2, upper_limit = 8, m=100)

def initialize_uniform(self, lower_limit = -3, upper_limit = 3):
    size = 20
    Y =  np.random.uniform(lower_limit, upper_limit, size = size)
    return

agents = [20,50,80,100] # common wiener noise
for k in agents:
  basecbo = BaseCBO(function = rastrigin(dim = 20), pos_vec = 20, n_agents = k, total_time = 100)
  success_rate(basecbo,lower_limit = -6, upper_limit = 6, m=100)

agents = [20, 50, 80, 100] # with common poisson noise different wiener noise
for k in agents:
  jumpcbo = JumpCBO(function = rastrigin(dim = 20), pos_vec = 20, n_agents = k, beta = 1, total_time = 100, alpha = 20, lambda_val = 20, type_rv="poisson")
  success_rate(jumpcbo,m=100, lower_limit= -6, upper_limit = 6)

agents = [20, 50, 80, 100] # with common poisson noise different wiener noise
for k in agents:
  jumpcbo = JumpCBO(function = rastrigin(dim = 20), pos_vec = 20, n_agents = k, beta = 1, total_time = 100, alpha = 30, lambda_val = 20, type_rv="poisson")
  success_rate(jumpcbo,m=100, lower_limit= -6, upper_limit = 6)